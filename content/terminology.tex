\section{Terminology}
\label{sec:terminology}

\subsection{Multi-Tenancy}

Software as a Service products are usually built for multi-user usage. In Multi-tenancy, these users belong to one tenant and need to be isolated from other tenants' users. Each tenant has hereby access to an isolated multi-user system \cite{Chong2006a}. To sell the products to a wide variety of tenants the software is usually heavily customizable and secured by Service Level Agreements~\cite{Bezemer2010}.

Multi-Tenancy itself should not be confused with multi-tenancy architecture which differs from multi-instance architecture by servicing multiple tenants from a single instance of the software~\cite{Shao2011} in contrast to providing a dedicated instance of the software to each tenant.

%What is multi tenancy? How does it relate to multi user?
  %multi-user is a subset of multi-tenant
  %every tenant is a multi-user system in itself
  %Multi-tenant =  Multi-User + SLA + Heavily customizable [DELFT]
\subsection{Version}

Considering software versioning two different definitions exists. One is the \emph{product version}, which identifies a certain stage of the software in a release lifecycle. The other is a \emph{code revision}, which is managed by a version control system as part of software configuration management \cite{swebook}.

% coupling: It might be belong to an actual product version
As the latter definition in contrast to the former is mainly dealing with changes to the source code, differences in code revisions might not be distinguishable by the users, whereas product versions are inherently visible to the users. The distinction between product version and code revision will be made again in Section~\ref{sec:backend}. When we talk about version without specifying the type, we refer to product versions.

%(Frontend:UI/Backend:Busisness Logix/DB)
  %- // how can we provide a versioning for all these layers with minimal cost. where the tenant can choose.
  %- // how can we make sure that everything is in sync and consistent
  %- granularity of versioning depends on how tight stack is coupled
  %- users interface with versioning in frontend (tenant or even user specific)
  %- backend/db is only versioned forward for whole tenant
  %- stick with product version instead of code revision
%- Configuration
  %- variables in database in shared table layout
%- Customization (int.)
  %- code / templating executed in the context of the saas provider
  %- huge changes
  %- // Eyad does not care about config/customization
  %- // predefined columns
  %- // Eyad doesn't care
  %- -> we handle just like configuration
  %Customization (internal)
  %Tenant-specific changes that run within the application context
  %Examples:
  %Templates, Custom DB fields, DSLs

%- Extension (ext.)
  %- // E column extension
  %- not focused on marketplace
  %- // truly external extensions are 2 much
  %- // Eyad doesn't care, we don't do
  %- -> we don't care
  %Extension (external)
  %Tenant-specific changes that run outside the application and interface with it over an API
  %Example:
  %Third-party add-ons in a marketplace
  %addon is in a way just a regular customer as it is truly external
  %we only have to consider customization in our architecture




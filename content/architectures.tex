\section{Architecture}
\label{sec:architecture}

In this section we first clarify the \emph{application stack} we are assuming the SaaS application to have. Then we explain the different architectural approaches to implement versioning of SaaS, with \emph{multi-instance} as well as \emph{shared-instance} on the different application stack layers.

One important assumption we make for versioning is, that each tenant and therefore also all users of a tenant use the same version at the same time. Practially this means that each tenant has a dedicated migration point in which they decide to switch their version. This switch affects all their users at the same time. Users aren't allowed to individually choose their version.

\subsection{Application Stack}

\begin{wrapfigure}{r}{0.4\textwidth}
\centering
\includegraphics[]{stack.pdf}
\caption{Simplified Application Stack}
\label{fig:stack}
\end{wrapfigure}

To understand the architecture better, we first want to look at the SaaS application stack as displayed in Figure~\ref{fig:stack}. We derived this stack from our experience with developing SaaS ourselves as well as stacks we have seen in related papers (TODO references).

We assume a separation between the front-end, back-end and database layer. The front-end layer is mainly concerned with the user interface. In a SaaS it will usually be delivered to the user's browser within a request/response cycle. The back-end layer is concerned with the application and business logic. It takes requests from the front-end layer and accordingly communicated with the database layer. The front-end and back-end layers are stateless, because all state is kept in the database layer.

To focus our research, we omitted some details of the stack. First we did were not concerned with caching as well as load balancing. Furthermore we omitted how user management is done, especially with regards to authentication.

\subsection{Multi-Instance}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{multiinstance.pdf}
\caption{Example for a version-supporting Multi-Instance Architecture}
\label{fig:multiinstance}
\end{figure}

In a multi-instance architecture the whole application stack is deployed several times on distinct resources. You can see an example in Figure~\ref{fig:multiinstance}. Usually the multi-instance architecture serves the purpose of provisioning resources for each tenant individually for horizontal scaling (TODO citation) as well as being able to develop a single-tenant application instead of having to do the engineering overhead of developing a multi-tenant application. This approach can also be used for versioning, where we see two variants:

\paragraph{Single instance per tenant} When every tenant has their own application stack instance running, these instances can be versioned by deploying the respective software version on the tentant's instance.
\paragraph{Single instance per version with multiple tenants} When every instance has a specific version, the instances in turn can be hosts for multiple tenants by using the shared-instance mechanisms explained in the following section.

Using a multi-instance architecture has the benefits that it is the most 'natural way' to provide a SaaS, since the developer does not have to deal with issues concerning multi-tenancy in one instance, like vertical scaling or isolation. Among the drawbacks are that multi-instance has a bad resource consolidation factor, thus if e.g. one tenant uses many resources but another uses none, the unused resources can't be allocated to the spiking tenant easily. Also the maintentance cost increases with the numer of tenants and there is no economy of scale working in favor of the SaaS provider here.

Versioning-wise the actual stack is not version-aware and thus can be built without versioning in mind. Instead versioning is handled on the deployment level. Migrations between versions might then need significant operations engineering effort.

\subsection{Shared-Instance}

\subsubsection{Frontend}
  Web application
  tight coupling between backend and frontend
  simultaneously versioned
  versioning concern in backend

  API consumers (e.g. native apps)
  loose coupling between backend and frontend
  backend needs to provide different versions of API
  api consumers choose version

  Frontend API Versioning
    In URL:
      http://api.com/v1/resource.json?version=1
    Accept Header:
      Accept: application/json+v1
    Application Flag:

\subsubsection{Backend}
\paragraph{Shared-Instance 1:1}
geiles diagram

a product ver = code rev


Pro
Versioning is external to application code

Contra
heterogeneous deployment
worse consolidation factor
intelligent routing layer needed
forking of code base makes security patches difficult to apply



\paragraph{Shared-Instance 1:n}
geiles diagram


version choice is on app server


Pro
good consolidation
homogenous deployment
more flexibility: fine grained feature selection

Contra
increased code complexity
abandoning old versions needs cleanup



inside of code base are many version checks "if version == 1.4 ..."
more flexibility in choosing version, maybe not choose version but choose only features

high cost for abandoning old version to clean code base

\lstset{language=Ruby, caption=code snippet, label=code}
\begin{lstlisting}
  if(user.has_version?):
    do_something()
  end
\end{lstlisting}

\subsubsection{Database}

\paragraph{Different versions share same schema}
db is version agnostic

\paragraph{Different versions need separate schemas}
How to version schemas?

  Database needs to support several schemas for a table at the same time

  No DBMs supporting this is known to us

  Thus versioning has to happen in the backend

  \paragraph{Different tables for each schema}
  \lstset{language=SQL, caption=sql, label=sql}
  \begin{lstlisting}
    create table users_v1;
    create table users_v2;
    create table users_v3;
  \end{lstlisting}

  Pro:
  Works well if not too many versions

  Con:
  Messy design if many versions


  \paragraph{Pivot tables}

  bild von "An Elastic Multi-tenant Database Schema for Software as a Service"

  reduce dbms more to a key value store
  as used with salesforce

\paragraph{Migration of data}
  version is chosen per tenant
  data migrations need time
  data migrations might need downtime
  on-the-fly migrations possible

